// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v4.23.4
// source: live_telemetry_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "me.williamhester.kdash.enduranceweb";

export interface ConnectRequest {
  sessionIdentifier: SessionIdentifier | undefined;
}

export interface SessionIdentifier {
  sessionId: number;
  subSessionId: number;
  simSessionNumber: number;
  carNumber: string;
}

export interface QueryTelemetryRequest {
  sessionIdentifier:
    | SessionIdentifier
    | undefined;
  /**
   * Rate at which data should be sampled.
   * Default (zero) will send data at the max sample rate.
   */
  sampleRateHz: number;
  /**
   * The session time to start sending data from.
   * Default (zero) will send data from the beginning of the session.
   */
  minSessionTime: number;
  /**
   * The session time at which the data should end.
   * Default (zero) will stream live data.
   */
  maxSessionTime: number;
  /**
   * The distance of the target driver to start sending data from.
   * Default (zero) will send data from the beginning of the session.
   */
  minDriverDistance: number;
  /**
   * The distance of the target driver at which the data should end.
   * Default (zero) will stream live data.
   */
  maxDriverDistance: number;
  /** A list of queries that should be executed for each telemetry value. */
  queries: string[];
}

/** The QueryTelemetryResponse. The first message will always be a DataRange. All other messages will be TelemetryData. */
export interface QueryTelemetryResponse {
  dataRanges?: DataRanges | undefined;
  data?: TelemetryData | undefined;
}

export interface TelemetryData {
  /**
   * Each data point will contain the current session time.
   * Required.
   */
  sessionTime: number;
  /**
   * Each data point will contain the current driver's distance.
   * Required.
   */
  driverDistance: number;
  /**
   * Values for each query requested in the QueryTelemetryRequest.
   * Required.
   */
  queryValues: number[];
}

export interface QueryRealtimeTelemetryRequest {
  sessionIdentifier:
    | SessionIdentifier
    | undefined;
  /** A list of queries that should be executed for each telemetry value. */
  queries: string[];
  /**
   * Rate at which data should be sampled.
   * Default (zero) will send data at the max sample rate.
   */
  sampleRateHz: number;
}

export interface QueryRealtimeTelemetryResponse {
  /**
   * Values for each query requested in the QueryTelemetryRequest. Unlike query_values, values are only returned if
   * they have changed from the previous value. Keys are the indices of the requests.
   * Optional.
   */
  sparseQueryValues: { [key: number]: QueryResult };
}

export interface QueryRealtimeTelemetryResponse_SparseQueryValuesEntry {
  key: number;
  value: QueryResult | undefined;
}

export interface QueryResult {
  scalar?: number | undefined;
  list?: ListValue | undefined;
}

export interface ListValue {
  values: number[];
}

/** The range of the queried data, even if it's outside the query range. */
export interface DataRange {
  /**
   * The minimum value in the dataset.
   * Required.
   */
  min: number;
  /**
   * The maximum value in the dataset.
   * Required.
   */
  max: number;
}

/** The ranges of data. There are ranges for both session time and driver distance (laps). */
export interface DataRanges {
  sessionTime: DataRange | undefined;
  driverDistance: DataRange | undefined;
}

export interface LapData {
  driverLap?: LapEntry | undefined;
  otherCarLap?: OtherCarLapEntry | undefined;
  driverStint?: StintEntry | undefined;
  otherCarStint?: OtherCarStintEntry | undefined;
}

export interface LapEntry {
  lapNum: number;
  driverName: string;
  position: number;
  lapTime: number;
  gapToLeader: number;
  fuelRemaining: number;
  fuelUsed: number;
  trackTemp: number;
  driverIncidents: number;
  teamIncidents: number;
  optionalRepairsRemaining: number;
  repairsRemaining: number;
  pitIn: boolean;
  pitOut: boolean;
  pitTime: number;
  maxSpeed: number;
}

export interface OtherCarLapEntry {
  carId: number;
  lapNum: number;
  driverName: string;
  position: number;
  lapTime: number;
  gapToLeader: number;
  trackTemp: number;
  pitIn: boolean;
  pitOut: boolean;
  pitTime: number;
}

export interface StintEntry {
  outLap: number;
  inLap: number;
  driverName: string;
  totalTime: number;
  lapTimes: number[];
  averageLapTime: number;
  fastestLapTime: number;
  trackTemp: number;
  incidents: number;
}

export interface OtherCarStintEntry {
  carIdx: number;
  outLap: number;
  inLap: number;
  driverName: string;
  totalTime: number;
  lapTimes: number[];
  averageLapTime: number;
  fastestLapTime: number;
  trackTemp: number;
}

export interface SessionInfo {
  drivers: Driver[];
}

export interface StaticSessionInfo {
  driverCarIdx: number;
  driverCarEstLapTime: number;
  isMulticlass: boolean;
  carClasses: CarClass[];
}

export interface Driver {
  carId: number;
  carNumber: number;
  carClassId: number;
  carClassName: string;
  driverName: string;
  teamName: string;
}

export interface CarClass {
  carClassId: number;
  carClassShortName: string;
  carClassColor: string;
}

export interface ListSessionsRequest {
}

export interface ListSessionsResponse {
  sessions: Session[];
}

export interface Session {
  sessionId: number;
  subSessionId: number;
  simSessionNumber: number;
  carNumber: string;
  trackName: string;
}

function createBaseConnectRequest(): ConnectRequest {
  return { sessionIdentifier: undefined };
}

export const ConnectRequest: MessageFns<ConnectRequest> = {
  encode(message: ConnectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionIdentifier !== undefined) {
      SessionIdentifier.encode(message.sessionIdentifier, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionIdentifier = SessionIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectRequest {
    return {
      sessionIdentifier: isSet(object.sessionIdentifier)
        ? SessionIdentifier.fromJSON(object.sessionIdentifier)
        : undefined,
    };
  },

  toJSON(message: ConnectRequest): unknown {
    const obj: any = {};
    if (message.sessionIdentifier !== undefined) {
      obj.sessionIdentifier = SessionIdentifier.toJSON(message.sessionIdentifier);
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectRequest>): ConnectRequest {
    return ConnectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectRequest>): ConnectRequest {
    const message = createBaseConnectRequest();
    message.sessionIdentifier = (object.sessionIdentifier !== undefined && object.sessionIdentifier !== null)
      ? SessionIdentifier.fromPartial(object.sessionIdentifier)
      : undefined;
    return message;
  },
};

function createBaseSessionIdentifier(): SessionIdentifier {
  return { sessionId: 0, subSessionId: 0, simSessionNumber: 0, carNumber: "" };
}

export const SessionIdentifier: MessageFns<SessionIdentifier> = {
  encode(message: SessionIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.subSessionId !== 0) {
      writer.uint32(16).int32(message.subSessionId);
    }
    if (message.simSessionNumber !== 0) {
      writer.uint32(24).int32(message.simSessionNumber);
    }
    if (message.carNumber !== "") {
      writer.uint32(34).string(message.carNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subSessionId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.simSessionNumber = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.carNumber = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionIdentifier {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      subSessionId: isSet(object.subSessionId) ? globalThis.Number(object.subSessionId) : 0,
      simSessionNumber: isSet(object.simSessionNumber) ? globalThis.Number(object.simSessionNumber) : 0,
      carNumber: isSet(object.carNumber) ? globalThis.String(object.carNumber) : "",
    };
  },

  toJSON(message: SessionIdentifier): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.subSessionId !== 0) {
      obj.subSessionId = Math.round(message.subSessionId);
    }
    if (message.simSessionNumber !== 0) {
      obj.simSessionNumber = Math.round(message.simSessionNumber);
    }
    if (message.carNumber !== "") {
      obj.carNumber = message.carNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<SessionIdentifier>): SessionIdentifier {
    return SessionIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionIdentifier>): SessionIdentifier {
    const message = createBaseSessionIdentifier();
    message.sessionId = object.sessionId ?? 0;
    message.subSessionId = object.subSessionId ?? 0;
    message.simSessionNumber = object.simSessionNumber ?? 0;
    message.carNumber = object.carNumber ?? "";
    return message;
  },
};

function createBaseQueryTelemetryRequest(): QueryTelemetryRequest {
  return {
    sessionIdentifier: undefined,
    sampleRateHz: 0,
    minSessionTime: 0,
    maxSessionTime: 0,
    minDriverDistance: 0,
    maxDriverDistance: 0,
    queries: [],
  };
}

export const QueryTelemetryRequest: MessageFns<QueryTelemetryRequest> = {
  encode(message: QueryTelemetryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionIdentifier !== undefined) {
      SessionIdentifier.encode(message.sessionIdentifier, writer.uint32(58).fork()).join();
    }
    if (message.sampleRateHz !== 0) {
      writer.uint32(9).double(message.sampleRateHz);
    }
    if (message.minSessionTime !== 0) {
      writer.uint32(17).double(message.minSessionTime);
    }
    if (message.maxSessionTime !== 0) {
      writer.uint32(25).double(message.maxSessionTime);
    }
    if (message.minDriverDistance !== 0) {
      writer.uint32(33).double(message.minDriverDistance);
    }
    if (message.maxDriverDistance !== 0) {
      writer.uint32(41).double(message.maxDriverDistance);
    }
    for (const v of message.queries) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTelemetryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTelemetryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sessionIdentifier = SessionIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.sampleRateHz = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.minSessionTime = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.maxSessionTime = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.minDriverDistance = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.maxDriverDistance = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.queries.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTelemetryRequest {
    return {
      sessionIdentifier: isSet(object.sessionIdentifier)
        ? SessionIdentifier.fromJSON(object.sessionIdentifier)
        : undefined,
      sampleRateHz: isSet(object.sampleRateHz) ? globalThis.Number(object.sampleRateHz) : 0,
      minSessionTime: isSet(object.minSessionTime) ? globalThis.Number(object.minSessionTime) : 0,
      maxSessionTime: isSet(object.maxSessionTime) ? globalThis.Number(object.maxSessionTime) : 0,
      minDriverDistance: isSet(object.minDriverDistance) ? globalThis.Number(object.minDriverDistance) : 0,
      maxDriverDistance: isSet(object.maxDriverDistance) ? globalThis.Number(object.maxDriverDistance) : 0,
      queries: globalThis.Array.isArray(object?.queries) ? object.queries.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: QueryTelemetryRequest): unknown {
    const obj: any = {};
    if (message.sessionIdentifier !== undefined) {
      obj.sessionIdentifier = SessionIdentifier.toJSON(message.sessionIdentifier);
    }
    if (message.sampleRateHz !== 0) {
      obj.sampleRateHz = message.sampleRateHz;
    }
    if (message.minSessionTime !== 0) {
      obj.minSessionTime = message.minSessionTime;
    }
    if (message.maxSessionTime !== 0) {
      obj.maxSessionTime = message.maxSessionTime;
    }
    if (message.minDriverDistance !== 0) {
      obj.minDriverDistance = message.minDriverDistance;
    }
    if (message.maxDriverDistance !== 0) {
      obj.maxDriverDistance = message.maxDriverDistance;
    }
    if (message.queries?.length) {
      obj.queries = message.queries;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTelemetryRequest>): QueryTelemetryRequest {
    return QueryTelemetryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTelemetryRequest>): QueryTelemetryRequest {
    const message = createBaseQueryTelemetryRequest();
    message.sessionIdentifier = (object.sessionIdentifier !== undefined && object.sessionIdentifier !== null)
      ? SessionIdentifier.fromPartial(object.sessionIdentifier)
      : undefined;
    message.sampleRateHz = object.sampleRateHz ?? 0;
    message.minSessionTime = object.minSessionTime ?? 0;
    message.maxSessionTime = object.maxSessionTime ?? 0;
    message.minDriverDistance = object.minDriverDistance ?? 0;
    message.maxDriverDistance = object.maxDriverDistance ?? 0;
    message.queries = object.queries?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryTelemetryResponse(): QueryTelemetryResponse {
  return { dataRanges: undefined, data: undefined };
}

export const QueryTelemetryResponse: MessageFns<QueryTelemetryResponse> = {
  encode(message: QueryTelemetryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataRanges !== undefined) {
      DataRanges.encode(message.dataRanges, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      TelemetryData.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTelemetryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTelemetryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataRanges = DataRanges.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = TelemetryData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTelemetryResponse {
    return {
      dataRanges: isSet(object.dataRanges) ? DataRanges.fromJSON(object.dataRanges) : undefined,
      data: isSet(object.data) ? TelemetryData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: QueryTelemetryResponse): unknown {
    const obj: any = {};
    if (message.dataRanges !== undefined) {
      obj.dataRanges = DataRanges.toJSON(message.dataRanges);
    }
    if (message.data !== undefined) {
      obj.data = TelemetryData.toJSON(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTelemetryResponse>): QueryTelemetryResponse {
    return QueryTelemetryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTelemetryResponse>): QueryTelemetryResponse {
    const message = createBaseQueryTelemetryResponse();
    message.dataRanges = (object.dataRanges !== undefined && object.dataRanges !== null)
      ? DataRanges.fromPartial(object.dataRanges)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? TelemetryData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseTelemetryData(): TelemetryData {
  return { sessionTime: 0, driverDistance: 0, queryValues: [] };
}

export const TelemetryData: MessageFns<TelemetryData> = {
  encode(message: TelemetryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionTime !== 0) {
      writer.uint32(9).double(message.sessionTime);
    }
    if (message.driverDistance !== 0) {
      writer.uint32(21).float(message.driverDistance);
    }
    writer.uint32(26).fork();
    for (const v of message.queryValues) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TelemetryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTelemetryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.sessionTime = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.driverDistance = reader.float();
          continue;
        }
        case 3: {
          if (tag === 25) {
            message.queryValues.push(reader.double());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.queryValues.push(reader.double());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TelemetryData {
    return {
      sessionTime: isSet(object.sessionTime) ? globalThis.Number(object.sessionTime) : 0,
      driverDistance: isSet(object.driverDistance) ? globalThis.Number(object.driverDistance) : 0,
      queryValues: globalThis.Array.isArray(object?.queryValues)
        ? object.queryValues.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: TelemetryData): unknown {
    const obj: any = {};
    if (message.sessionTime !== 0) {
      obj.sessionTime = message.sessionTime;
    }
    if (message.driverDistance !== 0) {
      obj.driverDistance = message.driverDistance;
    }
    if (message.queryValues?.length) {
      obj.queryValues = message.queryValues;
    }
    return obj;
  },

  create(base?: DeepPartial<TelemetryData>): TelemetryData {
    return TelemetryData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TelemetryData>): TelemetryData {
    const message = createBaseTelemetryData();
    message.sessionTime = object.sessionTime ?? 0;
    message.driverDistance = object.driverDistance ?? 0;
    message.queryValues = object.queryValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryRealtimeTelemetryRequest(): QueryRealtimeTelemetryRequest {
  return { sessionIdentifier: undefined, queries: [], sampleRateHz: 0 };
}

export const QueryRealtimeTelemetryRequest: MessageFns<QueryRealtimeTelemetryRequest> = {
  encode(message: QueryRealtimeTelemetryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionIdentifier !== undefined) {
      SessionIdentifier.encode(message.sessionIdentifier, writer.uint32(26).fork()).join();
    }
    for (const v of message.queries) {
      writer.uint32(10).string(v!);
    }
    if (message.sampleRateHz !== 0) {
      writer.uint32(17).double(message.sampleRateHz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRealtimeTelemetryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRealtimeTelemetryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionIdentifier = SessionIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queries.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.sampleRateHz = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRealtimeTelemetryRequest {
    return {
      sessionIdentifier: isSet(object.sessionIdentifier)
        ? SessionIdentifier.fromJSON(object.sessionIdentifier)
        : undefined,
      queries: globalThis.Array.isArray(object?.queries) ? object.queries.map((e: any) => globalThis.String(e)) : [],
      sampleRateHz: isSet(object.sampleRateHz) ? globalThis.Number(object.sampleRateHz) : 0,
    };
  },

  toJSON(message: QueryRealtimeTelemetryRequest): unknown {
    const obj: any = {};
    if (message.sessionIdentifier !== undefined) {
      obj.sessionIdentifier = SessionIdentifier.toJSON(message.sessionIdentifier);
    }
    if (message.queries?.length) {
      obj.queries = message.queries;
    }
    if (message.sampleRateHz !== 0) {
      obj.sampleRateHz = message.sampleRateHz;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRealtimeTelemetryRequest>): QueryRealtimeTelemetryRequest {
    return QueryRealtimeTelemetryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRealtimeTelemetryRequest>): QueryRealtimeTelemetryRequest {
    const message = createBaseQueryRealtimeTelemetryRequest();
    message.sessionIdentifier = (object.sessionIdentifier !== undefined && object.sessionIdentifier !== null)
      ? SessionIdentifier.fromPartial(object.sessionIdentifier)
      : undefined;
    message.queries = object.queries?.map((e) => e) || [];
    message.sampleRateHz = object.sampleRateHz ?? 0;
    return message;
  },
};

function createBaseQueryRealtimeTelemetryResponse(): QueryRealtimeTelemetryResponse {
  return { sparseQueryValues: {} };
}

export const QueryRealtimeTelemetryResponse: MessageFns<QueryRealtimeTelemetryResponse> = {
  encode(message: QueryRealtimeTelemetryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.sparseQueryValues).forEach(([key, value]) => {
      QueryRealtimeTelemetryResponse_SparseQueryValuesEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRealtimeTelemetryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRealtimeTelemetryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = QueryRealtimeTelemetryResponse_SparseQueryValuesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.sparseQueryValues[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRealtimeTelemetryResponse {
    return {
      sparseQueryValues: isObject(object.sparseQueryValues)
        ? Object.entries(object.sparseQueryValues).reduce<{ [key: number]: QueryResult }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = QueryResult.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryRealtimeTelemetryResponse): unknown {
    const obj: any = {};
    if (message.sparseQueryValues) {
      const entries = Object.entries(message.sparseQueryValues);
      if (entries.length > 0) {
        obj.sparseQueryValues = {};
        entries.forEach(([k, v]) => {
          obj.sparseQueryValues[k] = QueryResult.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRealtimeTelemetryResponse>): QueryRealtimeTelemetryResponse {
    return QueryRealtimeTelemetryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRealtimeTelemetryResponse>): QueryRealtimeTelemetryResponse {
    const message = createBaseQueryRealtimeTelemetryResponse();
    message.sparseQueryValues = Object.entries(object.sparseQueryValues ?? {}).reduce<{ [key: number]: QueryResult }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = QueryResult.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseQueryRealtimeTelemetryResponse_SparseQueryValuesEntry(): QueryRealtimeTelemetryResponse_SparseQueryValuesEntry {
  return { key: 0, value: undefined };
}

export const QueryRealtimeTelemetryResponse_SparseQueryValuesEntry: MessageFns<
  QueryRealtimeTelemetryResponse_SparseQueryValuesEntry
> = {
  encode(
    message: QueryRealtimeTelemetryResponse_SparseQueryValuesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      QueryResult.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRealtimeTelemetryResponse_SparseQueryValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRealtimeTelemetryResponse_SparseQueryValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = QueryResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRealtimeTelemetryResponse_SparseQueryValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? QueryResult.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: QueryRealtimeTelemetryResponse_SparseQueryValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = QueryResult.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<QueryRealtimeTelemetryResponse_SparseQueryValuesEntry>,
  ): QueryRealtimeTelemetryResponse_SparseQueryValuesEntry {
    return QueryRealtimeTelemetryResponse_SparseQueryValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueryRealtimeTelemetryResponse_SparseQueryValuesEntry>,
  ): QueryRealtimeTelemetryResponse_SparseQueryValuesEntry {
    const message = createBaseQueryRealtimeTelemetryResponse_SparseQueryValuesEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? QueryResult.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseQueryResult(): QueryResult {
  return { scalar: undefined, list: undefined };
}

export const QueryResult: MessageFns<QueryResult> = {
  encode(message: QueryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scalar !== undefined) {
      writer.uint32(9).double(message.scalar);
    }
    if (message.list !== undefined) {
      ListValue.encode(message.list, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.scalar = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.list = ListValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResult {
    return {
      scalar: isSet(object.scalar) ? globalThis.Number(object.scalar) : undefined,
      list: isSet(object.list) ? ListValue.fromJSON(object.list) : undefined,
    };
  },

  toJSON(message: QueryResult): unknown {
    const obj: any = {};
    if (message.scalar !== undefined) {
      obj.scalar = message.scalar;
    }
    if (message.list !== undefined) {
      obj.list = ListValue.toJSON(message.list);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryResult>): QueryResult {
    return QueryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryResult>): QueryResult {
    const message = createBaseQueryResult();
    message.scalar = object.scalar ?? undefined;
    message.list = (object.list !== undefined && object.list !== null) ? ListValue.fromPartial(object.list) : undefined;
    return message;
  },
};

function createBaseListValue(): ListValue {
  return { values: [] };
}

export const ListValue: MessageFns<ListValue> = {
  encode(message: ListValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 9) {
            message.values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.double());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListValue {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: ListValue): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<ListValue>): ListValue {
    return ListValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListValue>): ListValue {
    const message = createBaseListValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseDataRange(): DataRange {
  return { min: 0, max: 0 };
}

export const DataRange: MessageFns<DataRange> = {
  encode(message: DataRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(9).double(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(17).double(message.max);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.min = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.max = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataRange {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
    };
  },

  toJSON(message: DataRange): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    return obj;
  },

  create(base?: DeepPartial<DataRange>): DataRange {
    return DataRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataRange>): DataRange {
    const message = createBaseDataRange();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    return message;
  },
};

function createBaseDataRanges(): DataRanges {
  return { sessionTime: undefined, driverDistance: undefined };
}

export const DataRanges: MessageFns<DataRanges> = {
  encode(message: DataRanges, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionTime !== undefined) {
      DataRange.encode(message.sessionTime, writer.uint32(10).fork()).join();
    }
    if (message.driverDistance !== undefined) {
      DataRange.encode(message.driverDistance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataRanges {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataRanges();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionTime = DataRange.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.driverDistance = DataRange.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataRanges {
    return {
      sessionTime: isSet(object.sessionTime) ? DataRange.fromJSON(object.sessionTime) : undefined,
      driverDistance: isSet(object.driverDistance) ? DataRange.fromJSON(object.driverDistance) : undefined,
    };
  },

  toJSON(message: DataRanges): unknown {
    const obj: any = {};
    if (message.sessionTime !== undefined) {
      obj.sessionTime = DataRange.toJSON(message.sessionTime);
    }
    if (message.driverDistance !== undefined) {
      obj.driverDistance = DataRange.toJSON(message.driverDistance);
    }
    return obj;
  },

  create(base?: DeepPartial<DataRanges>): DataRanges {
    return DataRanges.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataRanges>): DataRanges {
    const message = createBaseDataRanges();
    message.sessionTime = (object.sessionTime !== undefined && object.sessionTime !== null)
      ? DataRange.fromPartial(object.sessionTime)
      : undefined;
    message.driverDistance = (object.driverDistance !== undefined && object.driverDistance !== null)
      ? DataRange.fromPartial(object.driverDistance)
      : undefined;
    return message;
  },
};

function createBaseLapData(): LapData {
  return { driverLap: undefined, otherCarLap: undefined, driverStint: undefined, otherCarStint: undefined };
}

export const LapData: MessageFns<LapData> = {
  encode(message: LapData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driverLap !== undefined) {
      LapEntry.encode(message.driverLap, writer.uint32(10).fork()).join();
    }
    if (message.otherCarLap !== undefined) {
      OtherCarLapEntry.encode(message.otherCarLap, writer.uint32(18).fork()).join();
    }
    if (message.driverStint !== undefined) {
      StintEntry.encode(message.driverStint, writer.uint32(26).fork()).join();
    }
    if (message.otherCarStint !== undefined) {
      OtherCarStintEntry.encode(message.otherCarStint, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LapData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLapData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.driverLap = LapEntry.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otherCarLap = OtherCarLapEntry.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.driverStint = StintEntry.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.otherCarStint = OtherCarStintEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LapData {
    return {
      driverLap: isSet(object.driverLap) ? LapEntry.fromJSON(object.driverLap) : undefined,
      otherCarLap: isSet(object.otherCarLap) ? OtherCarLapEntry.fromJSON(object.otherCarLap) : undefined,
      driverStint: isSet(object.driverStint) ? StintEntry.fromJSON(object.driverStint) : undefined,
      otherCarStint: isSet(object.otherCarStint) ? OtherCarStintEntry.fromJSON(object.otherCarStint) : undefined,
    };
  },

  toJSON(message: LapData): unknown {
    const obj: any = {};
    if (message.driverLap !== undefined) {
      obj.driverLap = LapEntry.toJSON(message.driverLap);
    }
    if (message.otherCarLap !== undefined) {
      obj.otherCarLap = OtherCarLapEntry.toJSON(message.otherCarLap);
    }
    if (message.driverStint !== undefined) {
      obj.driverStint = StintEntry.toJSON(message.driverStint);
    }
    if (message.otherCarStint !== undefined) {
      obj.otherCarStint = OtherCarStintEntry.toJSON(message.otherCarStint);
    }
    return obj;
  },

  create(base?: DeepPartial<LapData>): LapData {
    return LapData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LapData>): LapData {
    const message = createBaseLapData();
    message.driverLap = (object.driverLap !== undefined && object.driverLap !== null)
      ? LapEntry.fromPartial(object.driverLap)
      : undefined;
    message.otherCarLap = (object.otherCarLap !== undefined && object.otherCarLap !== null)
      ? OtherCarLapEntry.fromPartial(object.otherCarLap)
      : undefined;
    message.driverStint = (object.driverStint !== undefined && object.driverStint !== null)
      ? StintEntry.fromPartial(object.driverStint)
      : undefined;
    message.otherCarStint = (object.otherCarStint !== undefined && object.otherCarStint !== null)
      ? OtherCarStintEntry.fromPartial(object.otherCarStint)
      : undefined;
    return message;
  },
};

function createBaseLapEntry(): LapEntry {
  return {
    lapNum: 0,
    driverName: "",
    position: 0,
    lapTime: 0,
    gapToLeader: 0,
    fuelRemaining: 0,
    fuelUsed: 0,
    trackTemp: 0,
    driverIncidents: 0,
    teamIncidents: 0,
    optionalRepairsRemaining: 0,
    repairsRemaining: 0,
    pitIn: false,
    pitOut: false,
    pitTime: 0,
    maxSpeed: 0,
  };
}

export const LapEntry: MessageFns<LapEntry> = {
  encode(message: LapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lapNum !== 0) {
      writer.uint32(8).int32(message.lapNum);
    }
    if (message.driverName !== "") {
      writer.uint32(18).string(message.driverName);
    }
    if (message.position !== 0) {
      writer.uint32(24).int32(message.position);
    }
    if (message.lapTime !== 0) {
      writer.uint32(33).double(message.lapTime);
    }
    if (message.gapToLeader !== 0) {
      writer.uint32(41).double(message.gapToLeader);
    }
    if (message.fuelRemaining !== 0) {
      writer.uint32(53).float(message.fuelRemaining);
    }
    if (message.fuelUsed !== 0) {
      writer.uint32(61).float(message.fuelUsed);
    }
    if (message.trackTemp !== 0) {
      writer.uint32(69).float(message.trackTemp);
    }
    if (message.driverIncidents !== 0) {
      writer.uint32(72).int32(message.driverIncidents);
    }
    if (message.teamIncidents !== 0) {
      writer.uint32(80).int32(message.teamIncidents);
    }
    if (message.optionalRepairsRemaining !== 0) {
      writer.uint32(93).float(message.optionalRepairsRemaining);
    }
    if (message.repairsRemaining !== 0) {
      writer.uint32(101).float(message.repairsRemaining);
    }
    if (message.pitIn !== false) {
      writer.uint32(104).bool(message.pitIn);
    }
    if (message.pitOut !== false) {
      writer.uint32(112).bool(message.pitOut);
    }
    if (message.pitTime !== 0) {
      writer.uint32(121).double(message.pitTime);
    }
    if (message.maxSpeed !== 0) {
      writer.uint32(133).float(message.maxSpeed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lapNum = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.driverName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.lapTime = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.gapToLeader = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.fuelRemaining = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.fuelUsed = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.trackTemp = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.driverIncidents = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.teamIncidents = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.optionalRepairsRemaining = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.repairsRemaining = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.pitIn = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.pitOut = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 121) {
            break;
          }

          message.pitTime = reader.double();
          continue;
        }
        case 16: {
          if (tag !== 133) {
            break;
          }

          message.maxSpeed = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LapEntry {
    return {
      lapNum: isSet(object.lapNum) ? globalThis.Number(object.lapNum) : 0,
      driverName: isSet(object.driverName) ? globalThis.String(object.driverName) : "",
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      lapTime: isSet(object.lapTime) ? globalThis.Number(object.lapTime) : 0,
      gapToLeader: isSet(object.gapToLeader) ? globalThis.Number(object.gapToLeader) : 0,
      fuelRemaining: isSet(object.fuelRemaining) ? globalThis.Number(object.fuelRemaining) : 0,
      fuelUsed: isSet(object.fuelUsed) ? globalThis.Number(object.fuelUsed) : 0,
      trackTemp: isSet(object.trackTemp) ? globalThis.Number(object.trackTemp) : 0,
      driverIncidents: isSet(object.driverIncidents) ? globalThis.Number(object.driverIncidents) : 0,
      teamIncidents: isSet(object.teamIncidents) ? globalThis.Number(object.teamIncidents) : 0,
      optionalRepairsRemaining: isSet(object.optionalRepairsRemaining)
        ? globalThis.Number(object.optionalRepairsRemaining)
        : 0,
      repairsRemaining: isSet(object.repairsRemaining) ? globalThis.Number(object.repairsRemaining) : 0,
      pitIn: isSet(object.pitIn) ? globalThis.Boolean(object.pitIn) : false,
      pitOut: isSet(object.pitOut) ? globalThis.Boolean(object.pitOut) : false,
      pitTime: isSet(object.pitTime) ? globalThis.Number(object.pitTime) : 0,
      maxSpeed: isSet(object.maxSpeed) ? globalThis.Number(object.maxSpeed) : 0,
    };
  },

  toJSON(message: LapEntry): unknown {
    const obj: any = {};
    if (message.lapNum !== 0) {
      obj.lapNum = Math.round(message.lapNum);
    }
    if (message.driverName !== "") {
      obj.driverName = message.driverName;
    }
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    if (message.lapTime !== 0) {
      obj.lapTime = message.lapTime;
    }
    if (message.gapToLeader !== 0) {
      obj.gapToLeader = message.gapToLeader;
    }
    if (message.fuelRemaining !== 0) {
      obj.fuelRemaining = message.fuelRemaining;
    }
    if (message.fuelUsed !== 0) {
      obj.fuelUsed = message.fuelUsed;
    }
    if (message.trackTemp !== 0) {
      obj.trackTemp = message.trackTemp;
    }
    if (message.driverIncidents !== 0) {
      obj.driverIncidents = Math.round(message.driverIncidents);
    }
    if (message.teamIncidents !== 0) {
      obj.teamIncidents = Math.round(message.teamIncidents);
    }
    if (message.optionalRepairsRemaining !== 0) {
      obj.optionalRepairsRemaining = message.optionalRepairsRemaining;
    }
    if (message.repairsRemaining !== 0) {
      obj.repairsRemaining = message.repairsRemaining;
    }
    if (message.pitIn !== false) {
      obj.pitIn = message.pitIn;
    }
    if (message.pitOut !== false) {
      obj.pitOut = message.pitOut;
    }
    if (message.pitTime !== 0) {
      obj.pitTime = message.pitTime;
    }
    if (message.maxSpeed !== 0) {
      obj.maxSpeed = message.maxSpeed;
    }
    return obj;
  },

  create(base?: DeepPartial<LapEntry>): LapEntry {
    return LapEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LapEntry>): LapEntry {
    const message = createBaseLapEntry();
    message.lapNum = object.lapNum ?? 0;
    message.driverName = object.driverName ?? "";
    message.position = object.position ?? 0;
    message.lapTime = object.lapTime ?? 0;
    message.gapToLeader = object.gapToLeader ?? 0;
    message.fuelRemaining = object.fuelRemaining ?? 0;
    message.fuelUsed = object.fuelUsed ?? 0;
    message.trackTemp = object.trackTemp ?? 0;
    message.driverIncidents = object.driverIncidents ?? 0;
    message.teamIncidents = object.teamIncidents ?? 0;
    message.optionalRepairsRemaining = object.optionalRepairsRemaining ?? 0;
    message.repairsRemaining = object.repairsRemaining ?? 0;
    message.pitIn = object.pitIn ?? false;
    message.pitOut = object.pitOut ?? false;
    message.pitTime = object.pitTime ?? 0;
    message.maxSpeed = object.maxSpeed ?? 0;
    return message;
  },
};

function createBaseOtherCarLapEntry(): OtherCarLapEntry {
  return {
    carId: 0,
    lapNum: 0,
    driverName: "",
    position: 0,
    lapTime: 0,
    gapToLeader: 0,
    trackTemp: 0,
    pitIn: false,
    pitOut: false,
    pitTime: 0,
  };
}

export const OtherCarLapEntry: MessageFns<OtherCarLapEntry> = {
  encode(message: OtherCarLapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.carId !== 0) {
      writer.uint32(8).int32(message.carId);
    }
    if (message.lapNum !== 0) {
      writer.uint32(16).int32(message.lapNum);
    }
    if (message.driverName !== "") {
      writer.uint32(26).string(message.driverName);
    }
    if (message.position !== 0) {
      writer.uint32(32).int32(message.position);
    }
    if (message.lapTime !== 0) {
      writer.uint32(41).double(message.lapTime);
    }
    if (message.gapToLeader !== 0) {
      writer.uint32(49).double(message.gapToLeader);
    }
    if (message.trackTemp !== 0) {
      writer.uint32(61).float(message.trackTemp);
    }
    if (message.pitIn !== false) {
      writer.uint32(64).bool(message.pitIn);
    }
    if (message.pitOut !== false) {
      writer.uint32(72).bool(message.pitOut);
    }
    if (message.pitTime !== 0) {
      writer.uint32(81).double(message.pitTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OtherCarLapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOtherCarLapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.carId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lapNum = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.driverName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.lapTime = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.gapToLeader = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.trackTemp = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pitIn = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.pitOut = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.pitTime = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OtherCarLapEntry {
    return {
      carId: isSet(object.carId) ? globalThis.Number(object.carId) : 0,
      lapNum: isSet(object.lapNum) ? globalThis.Number(object.lapNum) : 0,
      driverName: isSet(object.driverName) ? globalThis.String(object.driverName) : "",
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      lapTime: isSet(object.lapTime) ? globalThis.Number(object.lapTime) : 0,
      gapToLeader: isSet(object.gapToLeader) ? globalThis.Number(object.gapToLeader) : 0,
      trackTemp: isSet(object.trackTemp) ? globalThis.Number(object.trackTemp) : 0,
      pitIn: isSet(object.pitIn) ? globalThis.Boolean(object.pitIn) : false,
      pitOut: isSet(object.pitOut) ? globalThis.Boolean(object.pitOut) : false,
      pitTime: isSet(object.pitTime) ? globalThis.Number(object.pitTime) : 0,
    };
  },

  toJSON(message: OtherCarLapEntry): unknown {
    const obj: any = {};
    if (message.carId !== 0) {
      obj.carId = Math.round(message.carId);
    }
    if (message.lapNum !== 0) {
      obj.lapNum = Math.round(message.lapNum);
    }
    if (message.driverName !== "") {
      obj.driverName = message.driverName;
    }
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    if (message.lapTime !== 0) {
      obj.lapTime = message.lapTime;
    }
    if (message.gapToLeader !== 0) {
      obj.gapToLeader = message.gapToLeader;
    }
    if (message.trackTemp !== 0) {
      obj.trackTemp = message.trackTemp;
    }
    if (message.pitIn !== false) {
      obj.pitIn = message.pitIn;
    }
    if (message.pitOut !== false) {
      obj.pitOut = message.pitOut;
    }
    if (message.pitTime !== 0) {
      obj.pitTime = message.pitTime;
    }
    return obj;
  },

  create(base?: DeepPartial<OtherCarLapEntry>): OtherCarLapEntry {
    return OtherCarLapEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OtherCarLapEntry>): OtherCarLapEntry {
    const message = createBaseOtherCarLapEntry();
    message.carId = object.carId ?? 0;
    message.lapNum = object.lapNum ?? 0;
    message.driverName = object.driverName ?? "";
    message.position = object.position ?? 0;
    message.lapTime = object.lapTime ?? 0;
    message.gapToLeader = object.gapToLeader ?? 0;
    message.trackTemp = object.trackTemp ?? 0;
    message.pitIn = object.pitIn ?? false;
    message.pitOut = object.pitOut ?? false;
    message.pitTime = object.pitTime ?? 0;
    return message;
  },
};

function createBaseStintEntry(): StintEntry {
  return {
    outLap: 0,
    inLap: 0,
    driverName: "",
    totalTime: 0,
    lapTimes: [],
    averageLapTime: 0,
    fastestLapTime: 0,
    trackTemp: 0,
    incidents: 0,
  };
}

export const StintEntry: MessageFns<StintEntry> = {
  encode(message: StintEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outLap !== 0) {
      writer.uint32(8).int32(message.outLap);
    }
    if (message.inLap !== 0) {
      writer.uint32(16).int32(message.inLap);
    }
    if (message.driverName !== "") {
      writer.uint32(26).string(message.driverName);
    }
    if (message.totalTime !== 0) {
      writer.uint32(33).double(message.totalTime);
    }
    writer.uint32(42).fork();
    for (const v of message.lapTimes) {
      writer.double(v);
    }
    writer.join();
    if (message.averageLapTime !== 0) {
      writer.uint32(49).double(message.averageLapTime);
    }
    if (message.fastestLapTime !== 0) {
      writer.uint32(57).double(message.fastestLapTime);
    }
    if (message.trackTemp !== 0) {
      writer.uint32(69).float(message.trackTemp);
    }
    if (message.incidents !== 0) {
      writer.uint32(72).int32(message.incidents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StintEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStintEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.outLap = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inLap = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.driverName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.totalTime = reader.double();
          continue;
        }
        case 5: {
          if (tag === 41) {
            message.lapTimes.push(reader.double());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lapTimes.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.averageLapTime = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.fastestLapTime = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.trackTemp = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.incidents = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StintEntry {
    return {
      outLap: isSet(object.outLap) ? globalThis.Number(object.outLap) : 0,
      inLap: isSet(object.inLap) ? globalThis.Number(object.inLap) : 0,
      driverName: isSet(object.driverName) ? globalThis.String(object.driverName) : "",
      totalTime: isSet(object.totalTime) ? globalThis.Number(object.totalTime) : 0,
      lapTimes: globalThis.Array.isArray(object?.lapTimes) ? object.lapTimes.map((e: any) => globalThis.Number(e)) : [],
      averageLapTime: isSet(object.averageLapTime) ? globalThis.Number(object.averageLapTime) : 0,
      fastestLapTime: isSet(object.fastestLapTime) ? globalThis.Number(object.fastestLapTime) : 0,
      trackTemp: isSet(object.trackTemp) ? globalThis.Number(object.trackTemp) : 0,
      incidents: isSet(object.incidents) ? globalThis.Number(object.incidents) : 0,
    };
  },

  toJSON(message: StintEntry): unknown {
    const obj: any = {};
    if (message.outLap !== 0) {
      obj.outLap = Math.round(message.outLap);
    }
    if (message.inLap !== 0) {
      obj.inLap = Math.round(message.inLap);
    }
    if (message.driverName !== "") {
      obj.driverName = message.driverName;
    }
    if (message.totalTime !== 0) {
      obj.totalTime = message.totalTime;
    }
    if (message.lapTimes?.length) {
      obj.lapTimes = message.lapTimes;
    }
    if (message.averageLapTime !== 0) {
      obj.averageLapTime = message.averageLapTime;
    }
    if (message.fastestLapTime !== 0) {
      obj.fastestLapTime = message.fastestLapTime;
    }
    if (message.trackTemp !== 0) {
      obj.trackTemp = message.trackTemp;
    }
    if (message.incidents !== 0) {
      obj.incidents = Math.round(message.incidents);
    }
    return obj;
  },

  create(base?: DeepPartial<StintEntry>): StintEntry {
    return StintEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StintEntry>): StintEntry {
    const message = createBaseStintEntry();
    message.outLap = object.outLap ?? 0;
    message.inLap = object.inLap ?? 0;
    message.driverName = object.driverName ?? "";
    message.totalTime = object.totalTime ?? 0;
    message.lapTimes = object.lapTimes?.map((e) => e) || [];
    message.averageLapTime = object.averageLapTime ?? 0;
    message.fastestLapTime = object.fastestLapTime ?? 0;
    message.trackTemp = object.trackTemp ?? 0;
    message.incidents = object.incidents ?? 0;
    return message;
  },
};

function createBaseOtherCarStintEntry(): OtherCarStintEntry {
  return {
    carIdx: 0,
    outLap: 0,
    inLap: 0,
    driverName: "",
    totalTime: 0,
    lapTimes: [],
    averageLapTime: 0,
    fastestLapTime: 0,
    trackTemp: 0,
  };
}

export const OtherCarStintEntry: MessageFns<OtherCarStintEntry> = {
  encode(message: OtherCarStintEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.carIdx !== 0) {
      writer.uint32(72).int32(message.carIdx);
    }
    if (message.outLap !== 0) {
      writer.uint32(8).int32(message.outLap);
    }
    if (message.inLap !== 0) {
      writer.uint32(16).int32(message.inLap);
    }
    if (message.driverName !== "") {
      writer.uint32(26).string(message.driverName);
    }
    if (message.totalTime !== 0) {
      writer.uint32(33).double(message.totalTime);
    }
    writer.uint32(42).fork();
    for (const v of message.lapTimes) {
      writer.double(v);
    }
    writer.join();
    if (message.averageLapTime !== 0) {
      writer.uint32(49).double(message.averageLapTime);
    }
    if (message.fastestLapTime !== 0) {
      writer.uint32(57).double(message.fastestLapTime);
    }
    if (message.trackTemp !== 0) {
      writer.uint32(69).float(message.trackTemp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OtherCarStintEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOtherCarStintEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.carIdx = reader.int32();
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.outLap = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inLap = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.driverName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.totalTime = reader.double();
          continue;
        }
        case 5: {
          if (tag === 41) {
            message.lapTimes.push(reader.double());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lapTimes.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.averageLapTime = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.fastestLapTime = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.trackTemp = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OtherCarStintEntry {
    return {
      carIdx: isSet(object.carIdx) ? globalThis.Number(object.carIdx) : 0,
      outLap: isSet(object.outLap) ? globalThis.Number(object.outLap) : 0,
      inLap: isSet(object.inLap) ? globalThis.Number(object.inLap) : 0,
      driverName: isSet(object.driverName) ? globalThis.String(object.driverName) : "",
      totalTime: isSet(object.totalTime) ? globalThis.Number(object.totalTime) : 0,
      lapTimes: globalThis.Array.isArray(object?.lapTimes) ? object.lapTimes.map((e: any) => globalThis.Number(e)) : [],
      averageLapTime: isSet(object.averageLapTime) ? globalThis.Number(object.averageLapTime) : 0,
      fastestLapTime: isSet(object.fastestLapTime) ? globalThis.Number(object.fastestLapTime) : 0,
      trackTemp: isSet(object.trackTemp) ? globalThis.Number(object.trackTemp) : 0,
    };
  },

  toJSON(message: OtherCarStintEntry): unknown {
    const obj: any = {};
    if (message.carIdx !== 0) {
      obj.carIdx = Math.round(message.carIdx);
    }
    if (message.outLap !== 0) {
      obj.outLap = Math.round(message.outLap);
    }
    if (message.inLap !== 0) {
      obj.inLap = Math.round(message.inLap);
    }
    if (message.driverName !== "") {
      obj.driverName = message.driverName;
    }
    if (message.totalTime !== 0) {
      obj.totalTime = message.totalTime;
    }
    if (message.lapTimes?.length) {
      obj.lapTimes = message.lapTimes;
    }
    if (message.averageLapTime !== 0) {
      obj.averageLapTime = message.averageLapTime;
    }
    if (message.fastestLapTime !== 0) {
      obj.fastestLapTime = message.fastestLapTime;
    }
    if (message.trackTemp !== 0) {
      obj.trackTemp = message.trackTemp;
    }
    return obj;
  },

  create(base?: DeepPartial<OtherCarStintEntry>): OtherCarStintEntry {
    return OtherCarStintEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OtherCarStintEntry>): OtherCarStintEntry {
    const message = createBaseOtherCarStintEntry();
    message.carIdx = object.carIdx ?? 0;
    message.outLap = object.outLap ?? 0;
    message.inLap = object.inLap ?? 0;
    message.driverName = object.driverName ?? "";
    message.totalTime = object.totalTime ?? 0;
    message.lapTimes = object.lapTimes?.map((e) => e) || [];
    message.averageLapTime = object.averageLapTime ?? 0;
    message.fastestLapTime = object.fastestLapTime ?? 0;
    message.trackTemp = object.trackTemp ?? 0;
    return message;
  },
};

function createBaseSessionInfo(): SessionInfo {
  return { drivers: [] };
}

export const SessionInfo: MessageFns<SessionInfo> = {
  encode(message: SessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.drivers) {
      Driver.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.drivers.push(Driver.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionInfo {
    return {
      drivers: globalThis.Array.isArray(object?.drivers) ? object.drivers.map((e: any) => Driver.fromJSON(e)) : [],
    };
  },

  toJSON(message: SessionInfo): unknown {
    const obj: any = {};
    if (message.drivers?.length) {
      obj.drivers = message.drivers.map((e) => Driver.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SessionInfo>): SessionInfo {
    return SessionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionInfo>): SessionInfo {
    const message = createBaseSessionInfo();
    message.drivers = object.drivers?.map((e) => Driver.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStaticSessionInfo(): StaticSessionInfo {
  return { driverCarIdx: 0, driverCarEstLapTime: 0, isMulticlass: false, carClasses: [] };
}

export const StaticSessionInfo: MessageFns<StaticSessionInfo> = {
  encode(message: StaticSessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driverCarIdx !== 0) {
      writer.uint32(8).int32(message.driverCarIdx);
    }
    if (message.driverCarEstLapTime !== 0) {
      writer.uint32(21).float(message.driverCarEstLapTime);
    }
    if (message.isMulticlass !== false) {
      writer.uint32(24).bool(message.isMulticlass);
    }
    for (const v of message.carClasses) {
      CarClass.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StaticSessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaticSessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.driverCarIdx = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.driverCarEstLapTime = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isMulticlass = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.carClasses.push(CarClass.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StaticSessionInfo {
    return {
      driverCarIdx: isSet(object.driverCarIdx) ? globalThis.Number(object.driverCarIdx) : 0,
      driverCarEstLapTime: isSet(object.driverCarEstLapTime) ? globalThis.Number(object.driverCarEstLapTime) : 0,
      isMulticlass: isSet(object.isMulticlass) ? globalThis.Boolean(object.isMulticlass) : false,
      carClasses: globalThis.Array.isArray(object?.carClasses)
        ? object.carClasses.map((e: any) => CarClass.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StaticSessionInfo): unknown {
    const obj: any = {};
    if (message.driverCarIdx !== 0) {
      obj.driverCarIdx = Math.round(message.driverCarIdx);
    }
    if (message.driverCarEstLapTime !== 0) {
      obj.driverCarEstLapTime = message.driverCarEstLapTime;
    }
    if (message.isMulticlass !== false) {
      obj.isMulticlass = message.isMulticlass;
    }
    if (message.carClasses?.length) {
      obj.carClasses = message.carClasses.map((e) => CarClass.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StaticSessionInfo>): StaticSessionInfo {
    return StaticSessionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StaticSessionInfo>): StaticSessionInfo {
    const message = createBaseStaticSessionInfo();
    message.driverCarIdx = object.driverCarIdx ?? 0;
    message.driverCarEstLapTime = object.driverCarEstLapTime ?? 0;
    message.isMulticlass = object.isMulticlass ?? false;
    message.carClasses = object.carClasses?.map((e) => CarClass.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDriver(): Driver {
  return { carId: 0, carNumber: 0, carClassId: 0, carClassName: "", driverName: "", teamName: "" };
}

export const Driver: MessageFns<Driver> = {
  encode(message: Driver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.carId !== 0) {
      writer.uint32(8).int32(message.carId);
    }
    if (message.carNumber !== 0) {
      writer.uint32(16).int32(message.carNumber);
    }
    if (message.carClassId !== 0) {
      writer.uint32(24).int32(message.carClassId);
    }
    if (message.carClassName !== "") {
      writer.uint32(34).string(message.carClassName);
    }
    if (message.driverName !== "") {
      writer.uint32(42).string(message.driverName);
    }
    if (message.teamName !== "") {
      writer.uint32(50).string(message.teamName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Driver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.carId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.carNumber = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.carClassId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.carClassName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.driverName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.teamName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Driver {
    return {
      carId: isSet(object.carId) ? globalThis.Number(object.carId) : 0,
      carNumber: isSet(object.carNumber) ? globalThis.Number(object.carNumber) : 0,
      carClassId: isSet(object.carClassId) ? globalThis.Number(object.carClassId) : 0,
      carClassName: isSet(object.carClassName) ? globalThis.String(object.carClassName) : "",
      driverName: isSet(object.driverName) ? globalThis.String(object.driverName) : "",
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
    };
  },

  toJSON(message: Driver): unknown {
    const obj: any = {};
    if (message.carId !== 0) {
      obj.carId = Math.round(message.carId);
    }
    if (message.carNumber !== 0) {
      obj.carNumber = Math.round(message.carNumber);
    }
    if (message.carClassId !== 0) {
      obj.carClassId = Math.round(message.carClassId);
    }
    if (message.carClassName !== "") {
      obj.carClassName = message.carClassName;
    }
    if (message.driverName !== "") {
      obj.driverName = message.driverName;
    }
    if (message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    return obj;
  },

  create(base?: DeepPartial<Driver>): Driver {
    return Driver.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Driver>): Driver {
    const message = createBaseDriver();
    message.carId = object.carId ?? 0;
    message.carNumber = object.carNumber ?? 0;
    message.carClassId = object.carClassId ?? 0;
    message.carClassName = object.carClassName ?? "";
    message.driverName = object.driverName ?? "";
    message.teamName = object.teamName ?? "";
    return message;
  },
};

function createBaseCarClass(): CarClass {
  return { carClassId: 0, carClassShortName: "", carClassColor: "" };
}

export const CarClass: MessageFns<CarClass> = {
  encode(message: CarClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.carClassId !== 0) {
      writer.uint32(8).int32(message.carClassId);
    }
    if (message.carClassShortName !== "") {
      writer.uint32(18).string(message.carClassShortName);
    }
    if (message.carClassColor !== "") {
      writer.uint32(26).string(message.carClassColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CarClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCarClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.carClassId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.carClassShortName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.carClassColor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CarClass {
    return {
      carClassId: isSet(object.carClassId) ? globalThis.Number(object.carClassId) : 0,
      carClassShortName: isSet(object.carClassShortName) ? globalThis.String(object.carClassShortName) : "",
      carClassColor: isSet(object.carClassColor) ? globalThis.String(object.carClassColor) : "",
    };
  },

  toJSON(message: CarClass): unknown {
    const obj: any = {};
    if (message.carClassId !== 0) {
      obj.carClassId = Math.round(message.carClassId);
    }
    if (message.carClassShortName !== "") {
      obj.carClassShortName = message.carClassShortName;
    }
    if (message.carClassColor !== "") {
      obj.carClassColor = message.carClassColor;
    }
    return obj;
  },

  create(base?: DeepPartial<CarClass>): CarClass {
    return CarClass.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CarClass>): CarClass {
    const message = createBaseCarClass();
    message.carClassId = object.carClassId ?? 0;
    message.carClassShortName = object.carClassShortName ?? "";
    message.carClassColor = object.carClassColor ?? "";
    return message;
  },
};

function createBaseListSessionsRequest(): ListSessionsRequest {
  return {};
}

export const ListSessionsRequest: MessageFns<ListSessionsRequest> = {
  encode(_: ListSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListSessionsRequest {
    return {};
  },

  toJSON(_: ListSessionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListSessionsRequest>): ListSessionsRequest {
    return ListSessionsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListSessionsRequest>): ListSessionsRequest {
    const message = createBaseListSessionsRequest();
    return message;
  },
};

function createBaseListSessionsResponse(): ListSessionsResponse {
  return { sessions: [] };
}

export const ListSessionsResponse: MessageFns<ListSessionsResponse> = {
  encode(message: ListSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions) ? object.sessions.map((e: any) => Session.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => Session.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionsResponse>): ListSessionsResponse {
    return ListSessionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionsResponse>): ListSessionsResponse {
    const message = createBaseListSessionsResponse();
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSession(): Session {
  return { sessionId: 0, subSessionId: 0, simSessionNumber: 0, carNumber: "", trackName: "" };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.subSessionId !== 0) {
      writer.uint32(16).int32(message.subSessionId);
    }
    if (message.simSessionNumber !== 0) {
      writer.uint32(24).int32(message.simSessionNumber);
    }
    if (message.carNumber !== "") {
      writer.uint32(34).string(message.carNumber);
    }
    if (message.trackName !== "") {
      writer.uint32(42).string(message.trackName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subSessionId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.simSessionNumber = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.carNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.trackName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      subSessionId: isSet(object.subSessionId) ? globalThis.Number(object.subSessionId) : 0,
      simSessionNumber: isSet(object.simSessionNumber) ? globalThis.Number(object.simSessionNumber) : 0,
      carNumber: isSet(object.carNumber) ? globalThis.String(object.carNumber) : "",
      trackName: isSet(object.trackName) ? globalThis.String(object.trackName) : "",
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.subSessionId !== 0) {
      obj.subSessionId = Math.round(message.subSessionId);
    }
    if (message.simSessionNumber !== 0) {
      obj.simSessionNumber = Math.round(message.simSessionNumber);
    }
    if (message.carNumber !== "") {
      obj.carNumber = message.carNumber;
    }
    if (message.trackName !== "") {
      obj.trackName = message.trackName;
    }
    return obj;
  },

  create(base?: DeepPartial<Session>): Session {
    return Session.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Session>): Session {
    const message = createBaseSession();
    message.sessionId = object.sessionId ?? 0;
    message.subSessionId = object.subSessionId ?? 0;
    message.simSessionNumber = object.simSessionNumber ?? 0;
    message.carNumber = object.carNumber ?? "";
    message.trackName = object.trackName ?? "";
    return message;
  },
};

export type LiveTelemetryServiceDefinition = typeof LiveTelemetryServiceDefinition;
export const LiveTelemetryServiceDefinition = {
  name: "LiveTelemetryService",
  fullName: "me.williamhester.kdash.enduranceweb.LiveTelemetryService",
  methods: {
    queryTelemetry: {
      name: "QueryTelemetry",
      requestType: QueryTelemetryRequest,
      requestStream: false,
      responseType: QueryTelemetryResponse,
      responseStream: true,
      options: {},
    },
    queryRealtimeTelemetry: {
      name: "QueryRealtimeTelemetry",
      requestType: QueryRealtimeTelemetryRequest,
      requestStream: false,
      responseType: QueryRealtimeTelemetryResponse,
      responseStream: true,
      options: {},
    },
    monitorLaps: {
      name: "MonitorLaps",
      requestType: ConnectRequest,
      requestStream: false,
      responseType: LapData,
      responseStream: true,
      options: {},
    },
    monitorSessionInfo: {
      name: "MonitorSessionInfo",
      requestType: ConnectRequest,
      requestStream: false,
      responseType: SessionInfo,
      responseStream: true,
      options: {},
    },
    getStaticSessionInfo: {
      name: "GetStaticSessionInfo",
      requestType: ConnectRequest,
      requestStream: false,
      responseType: StaticSessionInfo,
      responseStream: false,
      options: {},
    },
    listSessions: {
      name: "ListSessions",
      requestType: ListSessionsRequest,
      requestStream: false,
      responseType: ListSessionsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface LiveTelemetryServiceImplementation<CallContextExt = {}> {
  queryTelemetry(
    request: QueryTelemetryRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<QueryTelemetryResponse>>;
  queryRealtimeTelemetry(
    request: QueryRealtimeTelemetryRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<QueryRealtimeTelemetryResponse>>;
  monitorLaps(
    request: ConnectRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<LapData>>;
  monitorSessionInfo(
    request: ConnectRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SessionInfo>>;
  getStaticSessionInfo(
    request: ConnectRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StaticSessionInfo>>;
  listSessions(
    request: ListSessionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSessionsResponse>>;
}

export interface LiveTelemetryServiceClient<CallOptionsExt = {}> {
  queryTelemetry(
    request: DeepPartial<QueryTelemetryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<QueryTelemetryResponse>;
  queryRealtimeTelemetry(
    request: DeepPartial<QueryRealtimeTelemetryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<QueryRealtimeTelemetryResponse>;
  monitorLaps(request: DeepPartial<ConnectRequest>, options?: CallOptions & CallOptionsExt): AsyncIterable<LapData>;
  monitorSessionInfo(
    request: DeepPartial<ConnectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SessionInfo>;
  getStaticSessionInfo(
    request: DeepPartial<ConnectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StaticSessionInfo>;
  listSessions(
    request: DeepPartial<ListSessionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSessionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
