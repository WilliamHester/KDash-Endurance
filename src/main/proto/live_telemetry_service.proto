syntax = "proto3";

package me.williamhester.kdash.enduranceweb;

option java_package = "me.williamhester.kdash.enduranceweb.proto";
option java_multiple_files = true;

service LiveTelemetryService {
   rpc QueryTelemetry(QueryTelemetryRequest) returns (stream QueryTelemetryResponse);

   rpc QueryRealtimeTelemetry(QueryRealtimeTelemetryRequest) returns (stream QueryRealtimeTelemetryResponse);

   rpc MonitorLaps(ConnectRequest) returns (stream LapData);

   rpc MonitorSessionInfo(ConnectRequest) returns (stream SessionInfo);

   rpc ListSessions(ListSessionsRequest) returns (ListSessionsResponse);
}

message ConnectRequest {
   SessionIdentifier session_identifier = 1;
}

message SessionIdentifier {
   int32 session_id = 1;
   int32 sub_session_id = 2;
   int32 sim_session_number = 3;
   string car_number = 4;
}

message QueryTelemetryRequest {
   SessionIdentifier session_identifier = 7;

   // Rate at which data should be sampled.
   // Default (zero) will send data at the max sample rate.
   double sample_rate_hz = 1;

   // The session time to start sending data from.
   // Default (zero) will send data from the beginning of the session.
   double min_session_time = 2;

   // The session time at which the data should end.
   // Default (zero) will stream live data.
   double max_session_time = 3;

   // The distance of the target driver to start sending data from.
   // Default (zero) will send data from the beginning of the session.
   double min_driver_distance = 4;

   // The distance of the target driver at which the data should end.
   // Default (zero) will stream live data.
   double max_driver_distance = 5;

   // A list of queries that should be executed for each telemetry value.
   repeated string queries = 6;
}

// The QueryTelemetryResponse. The first message will always be a DataRange. All other messages will be TelemetryData.
message QueryTelemetryResponse {
   oneof payload {
      DataRanges data_ranges = 1;
      TelemetryData data = 2;
   }
}

message TelemetryData {
   // Each data point will contain the current session time.
   // Required.
   double session_time = 1;

   // Each data point will contain the current driver's distance.
   // Required.
   float driver_distance = 2;

   // Values for each query requested in the QueryTelemetryRequest.
   // Required.
   repeated double query_values = 3;
}

message QueryRealtimeTelemetryRequest {
   SessionIdentifier session_identifier = 3;

   // A list of queries that should be executed for each telemetry value.
   repeated string queries = 1;

   // Rate at which data should be sampled.
   // Default (zero) will send data at the max sample rate.
   double sample_rate_hz = 2;
}

message QueryRealtimeTelemetryResponse {
   // Values for each query requested in the QueryTelemetryRequest. Unlike query_values, values are only returned if
   // they have changed from the previous value. Keys are the indices of the requests.
   // Optional.
   map<int32, QueryResult> sparse_query_values = 1;
}

message QueryResult {
   oneof value {
      double scalar = 1;
      ListValue list = 2;
   }
}

message ListValue {
   repeated double values = 1;
}

// The range of the queried data, even if it's outside the query range.
message DataRange {
   // The minimum value in the dataset.
   // Required.
   double min = 1;
   // The maximum value in the dataset.
   // Required.
   double max = 2;
}

// The ranges of data. There are ranges for both session time and driver distance (laps).
message DataRanges {
   DataRange session_time = 1;
   DataRange driver_distance = 2;
}

message LapData {
   oneof lap {
      LapEntry driver_lap = 1;
      OtherCarLapEntry other_car_lap = 2;
      StintEntry driver_stint = 3;
      OtherCarStintEntry other_car_stint = 4;
   }
}

message LapEntry {
   int32 lap_num = 1;
   string driver_name = 2;
   int32 position = 3;
   double lap_time = 4;
   double gap_to_leader = 5;
   float fuel_remaining = 6;
   float fuel_used = 7;
   float track_temp = 8;
   int32 driver_incidents = 9;
   int32 team_incidents = 10;
   float optional_repairs_remaining = 11;
   float repairs_remaining = 12;
   bool pit_in = 13;
   bool pit_out = 14;
   double pit_time = 15;
   float max_speed = 16;
}

message OtherCarLapEntry {
   int32 car_id = 1;
   int32 lap_num = 2;
   string driver_name = 3;
   int32 position = 4;
   double lap_time = 5;
   double gap_to_leader = 6;
   float track_temp = 7;
   bool pit_in = 8;
   bool pit_out = 9;
   double pit_time = 10;
}

message StintEntry {
   int32 out_lap = 1;
   int32 in_lap = 2;
   string driver_name = 3;
   double total_time = 4;
   repeated double lap_times = 5;
   double average_lap_time = 6;
   double fastest_lap_time = 7;
   float track_temp = 8;
   int32 incidents = 9;
}

message OtherCarStintEntry {
   int32 car_idx = 9;
   int32 out_lap = 1;
   int32 in_lap = 2;
   string driver_name = 3;
   double total_time = 4;
   repeated double lap_times = 5;
   double average_lap_time = 6;
   double fastest_lap_time = 7;
   float track_temp = 8;
}

message SessionInfo {
   int32 driver_car_idx = 2;
   repeated Driver drivers = 1;
}

message Driver {
   int32 car_id = 1;
   int32 car_number = 2;
   int32 car_class_id = 3;
   string car_class_name = 4;
   string driver_name = 5;
   string team_name = 6;
}

message ListSessionsRequest {}

message ListSessionsResponse {
   repeated Session sessions = 1;
}

message Session {
   int32 session_id = 1;
   int32 sub_session_id = 2;
   int32 sim_session_number = 3;
   string car_number = 4;

   string track_name = 5;
}
